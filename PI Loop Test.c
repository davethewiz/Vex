#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, dgtl1,  leftFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftBackEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightBackEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl12, brakes,         sensorDigitalOut)
#pragma config(Motor,  port2,           flywheel,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           flip,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRight,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int autonomousCount = 0;

void pre_auton() {
	bLCDBacklight = true;
	while (nLCDButtons != 2) {
		switch (autonomousCount) {
		case 0:
			displayLCDCenteredString(0, "4100A");
			displayLCDCenteredString(1, "AUTON SELECTOR");
			waitUntil(nLCDButtons != 0);
			if (nLCDButtons == 1) {
				waitUntil(nLCDButtons == 0);
				autonomousCount = 3;
				} else if (nLCDButtons == 4) {
				waitUntil(nLCDButtons == 0);
				autonomousCount++;
			}
			break;
		case 1:
			displayLCDCenteredString(0, "Blue (TFP)");
			displayLCDCenteredString(1, "");
			waitUntil(nLCDButtons != 0);
			if (nLCDButtons == 1) {
				waitUntil(nLCDButtons == 0);
				autonomousCount--;
				} else if (nLCDButtons == 4) {
				waitUntil(nLCDButtons == 0);
				autonomousCount++;
			}
			break;
		case 2:
			displayLCDCenteredString(0, "Red (TFP)");
			displayLCDCenteredString(1, "");
			waitUntil(nLCDButtons != 0);
			if (nLCDButtons == 1) {
				waitUntil(nLCDButtons == 0);
				autonomousCount--;
				} else if (nLCDButtons == 4) {
				waitUntil(nLCDButtons == 0);
				autonomousCount++;
			}
			break;
		case 3:
			displayLCDCenteredString(0, "Top Flag Hit");
			displayLCDCenteredString(1, "");
			waitUntil(nLCDButtons != 0);
			if (nLCDButtons == 1) {
				waitUntil(nLCDButtons == 0);
				autonomousCount--;
				} else if (nLCDButtons == 4) {
				waitUntil(nLCDButtons == 0);
				autonomousCount++;
			}
			break;
		}
		bLCDBacklight = false;
	}
}

void moveTiles(float tiles) {
	float distance = 650*abs(tiles);
	float Kp = 0.175; //.1275

	int direction = 1;
	if (tiles < 0)
		direction = -1;

	int leftIntegral = 0;
	int rightIntegral = 0;

	SensorValue(leftBackEncoder) = 0;
	SensorValue(leftFrontEncoder) = 0;
	SensorValue(rightBackEncoder) = 0;
	SensorValue(rightFrontEncoder) = 0;

	int wheelsAtTarget = 0;

	while (wheelsAtTarget < 3) {
		//making error variables
		int leftBackError = distance- 30 - abs(SensorValue(leftBackEncoder)); //10
		int leftFrontError = distance - 30 - abs(SensorValue(leftFrontEncoder)); //40
		int rightBackError = distance + 0 - abs(SensorValue(rightBackEncoder)); //30
		//int rightFrontError = distance - abs(SensorValue(rightFrontEncoder));

		if (abs(SensorValue(leftBackEncoder)) > distance && leftBackError != 0) {
			wheelsAtTarget++;
			leftBackError = 0;
		}

		if (abs(SensorValue(rightBackEncoder)) > distance && rightBackError != 0) {
			wheelsAtTarget++;
			rightBackError = 0;
		}

		if (abs(SensorValue(leftFrontEncoder)) > distance && leftBackError != 0) {
			wheelsAtTarget++;
			leftFrontError = 0;
		}

		/*if (abs(SensorValue(rightFrontEncoder)) > distance && rightFrontError != 0) {
			wheelsAtTarget++;
			rightFrontError = 0;
		}*/

		//setting speeds
		motor[backLeft] = direction * (leftBackError * Kp);
		motor[frontLeft] = direction * (leftFrontError * Kp); //+ (leftIntegral * Ki);
		motor[frontRight] = direction * (rightBackError * Kp);
		motor[backRight] = direction * (rightBackError * Kp); //+ (rightIntegral * Ki);
	}
}

void turnDegrees(int degrees) {
	float distance = 300*(abs(degrees)/90);
	float Kp = 0.65;

	int direction = 1;
	if (degrees < 0)
		direction = -1;

	SensorValue(leftBackEncoder) = SensorValue(leftFrontEncoder) = SensorValue(rightBackEncoder) = SensorValue(rightFrontEncoder) = 0;

	int wheelsAtTarget = 0;

	while (wheelsAtTarget < 3) {
		//making error variables
		int leftBackError = distance- 30 - abs(SensorValue(leftBackEncoder)); //10
		int leftFrontError = distance - 30 - abs(SensorValue(leftFrontEncoder)); //40
		int rightBackError = distance + 0 - abs(SensorValue(rightBackEncoder)); //30
		//int rightFrontError = distance - abs(SensorValue(rightFrontEncoder));

		if (abs(SensorValue(leftBackEncoder)) > distance && leftBackError != 0) {
			wheelsAtTarget++;
			leftBackError = 0;
		}

		if (abs(SensorValue(rightBackEncoder)) > distance && rightBackError != 0) {
			wheelsAtTarget++;
			rightBackError = 0;
		}

		if (abs(SensorValue(leftFrontEncoder)) > distance && leftBackError != 0) {
			wheelsAtTarget++;
			leftFrontError = 0;
		}

		/*if (abs(SensorValue(rightFrontEncoder)) > distance && rightFrontError != 0) {
			wheelsAtTarget++;
			rightFrontError = 0;
		}*/

		//setting speeds
		motor[backLeft] = direction * (leftBackError * Kp);
		motor[frontLeft] = direction * (leftFrontError * Kp); //+ (leftIntegral * Ki);
		motor[frontRight] = direction * -(rightBackError * Kp);
		motor[backRight] = direction * -(rightBackError * Kp); //+ (rightIntegral * Ki);
	}
}


void deployFlip() {
	motor[flip] = 75;
	delay(475);
	motor[flip] = 0;
}

void launchBall() {
	motor[flywheel] = 75;
	delay(4500);
	motor[intake] = 127;
	delay(1500);
	motor[flywheel] = 0;
	motor[intake] = 0;
}

void quickTurn(int direction) {
		motor[backRight] = motor[frontRight] = direction * 55;
		motor[backLeft] = motor[frontLeft] = direction * -55;
		delay(250);
		motor[backRight] = motor[frontRight] = direction * -55;
		motor[backLeft] = motor[frontLeft] = direction * 55;
		delay(225);
		motor[backRight] = motor[frontRight] = motor[backLeft] = motor[frontLeft] = 0;
}

task autonomous() { //1 = blue, -1 = red
	int side = 0;
	switch (autonomousCount) {
	case 1:
		side = 1; //blue
		launchBall();
		deployFlip();
		moveTiles(1.3);
		quickTurn(side);
		moveTiles(-1.3);
		turnDegrees(side * 90);
		moveTiles(-1.325);
		turnDegrees(side * -90);
		moveTiles(-1.65);
		break;
	case 2:
		side = -1; //red
		launchBall();
	//	deployFlip();
	//	moveTiles(1.4);
		//quickTurn(side);
	//	moveTiles(-1.4);
		turnDegrees(side * 90);
		moveTiles(-1.325);
		turnDegrees(side * -90);
		moveTiles(-1.65);
		break;
	case 3: //hit TF
		side = 1;
		launchBall();
	}
}

task autonomouss() {
	moveTiles(-1.25);
}

task usercontrol() {
	SensorValue(leftBackEncoder) = SensorValue(leftFrontEncoder) = SensorValue(rightBackEncoder) = SensorValue(rightFrontEncoder) = 0;
	while (true) {
		//base movement
		motor[backLeft] = motor[frontLeft] = vexRT[Ch3];

		motor[frontRight] = motor[backRight] = vexRT[Ch2];

		//intake control
		if (vexRT[Btn8D])
			motor[intake] = 127;
		else if (vexRT[Btn8U])
			motor[intake] = -127;
		else
			motor[intake] = 0;

		//lift control SLOW
		if (vexRT[Btn6U]) {
			motor[flip] = 127;
			} else if (VexRT[Btn6D]) {
			motor[flip] = -127;
			} else {
			motor[flip] = 0;
		}

		//Brakes
		SensorValue(brakes) = vexRT[Btn7U];

		//flywheel
		if (vexRT(Btn7R)) {
			motor[flywheel] = 75;
			} else {
			motor[flywheel] = 0;
		}
	}
}
