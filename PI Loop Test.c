#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           frontLeft,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void pre_auton() {
  bStopTasksBetweenModes = true;
}

void moveTiles(float tiles) {
	float distance = 615*tiles;
	float Kp = 0.185;
	float Ki = 0.05;
	int minSpeed = 40;

	int leftIntegral = 0;
	int rightIntegral = 0;

	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;
	while (abs(SensorValue(leftEncoder)) + abs(SensorValue(rightEncoder)) < distance*2) {
		  //making error variables
			int leftError = distance - abs(SensorValue(leftEncoder));
		  int rightError = distance - abs(SensorValue(rightEncoder));

		  //adding intelgral variables
		  leftIntegral += leftError;
		  rightIntegral += rightError;

		  //making integral not stupid
		  if (leftError <= 0 || abs(leftError) > minSpeed)
		  	leftIntegral = 0;
		 	if (rightError <= 0 || abs(rightError) > minSpeed)
		 		rightIntegral = 0;

		 	//setting speeds
			motor[backLeft] = motor[frontLeft] = (leftError * Kp) + (leftIntegral * Ki);
			motor[frontRight] = motor[backRight] = (rightError * Kp) + (rightIntegral * Ki);
	}
}

void turnDegrees(float tiles) {

}


task autonomous() {
	moveTiles(1);
}

task usercontrol() {
  while (true) {
  		motor[backLeft] = motor[frontLeft] = vexRT[Ch3];
  		motor[frontRight] = motor[backRight] = vexRT[Ch2];
  }
}
