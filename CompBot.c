#pragma config(Sensor, in1,    MLP,            sensorPotentiometer)
#pragma config(Sensor, in2,    MGP,            sensorPotentiometer)
#pragma config(Sensor, in3,    ,               sensorPotentiometer)
#pragma config(Motor,  port2,           topLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           botLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           botRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mobilLift,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


void pre_auton()
{
  bStopTasksBetweenModes = true;
}

void translateBase(byte speed, int time) {
	motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = speed;
	delay(time);
  motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = 0;
}

void rotateBase(byte speed, int time) { //making the speed negative flips the direction of rotation
	motor[botRightD] = motor[topRightD] = speed;
	motor[botLeftD] = motor[topLeftD] = -speed;
	delay(time);
  motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = 0;
}

void moveLift(byte speed, int time) {
	motor[rightLift] = motor[leftLift] = -speed;
	delay(time);
	motor[leftLift] = motor[rightLift] = 0;
}

void moveMobLift(byte speed, int time) {
	motor[mobilLift] = speed;
	delay(time);
	motor[mobilLift] = 0;
}

void moveClaw(byte speed, int time) {
	motor[claw] = speed;
	delay(time);
	motor[claw] = 0;
}

bool blueSide = false;

task autonomousL() {
	 moveMobLift(50, 1250*2); //raise mobil lift

}

task autonomous() //Fuk Boi AUTON
{
	//rotateBase(-50, 200); //rotate slighty for adjustment to new base rot beginning movement thing
	moveLift(100, 1200);
	moveMobLift(-100, 1000);
  translateBase(100, 3200); //move forward
  moveMobLift(50, 1300*2); //raise mobil lift
  delay(200); //wait a sec
  rotateBase(100,-100);
  translateBase(-75, 2650); //move backward
  if (blueSide) {
  	rotateBase(100,-3100/2);
  } else {
  	rotateBase(100, 3100/2); //rotate 180
	}
  translateBase(127, 3000); //move forward
  moveMobLift(-50, 1300*1.25); //move lift down
  translateBase(-100, 500); //move backward a little bit
  moveMobLift(127, 100); //move lift down
}

int clawMotorSpeed = 127;
int liftMotorSpeed = 100;
int thresholdML = 2500;
int thresholdLft = 2700;
bool manualLift = false;
bool manualMGL = false;

task usercontrol() //USER CONTROL
{
  while (true)
  {
  	//Normal Lift
		if (vexRT[Btn8U] == 1) {
			manualLift = false;
			thresholdLft = 1100;
		} else if (vexRT[Btn8D] == 1) {
			manualLift = false;
			thresholdLft = 2700;
		} else if (vexRT[Btn8L] == 1) {
			manualLift = false;
			thresholdLft = 2000;
		}

		if (vexRT[Btn6U] == 1) { //press 6U button
				manualLift = true;
				motor[rightLift] = motor[leftLift] = -liftMotorSpeed; //move lift to open
		} else if(vexRT[Btn6D] == 1) { //press 6D button
				manualLift = true;
				motor[rightLift] = motor[leftLift] = liftMotorSpeed; //move lift to close
		} else if (manualLift) { //if we don't have any buttons pressed
				motor[rightLift] = motor[leftLift] = 0; //don't move the lift
		}

		if (!manualLift) {
			if (SensorValue(MLP) > thresholdLft && SensorValue(MLP) < thresholdLft+100) {
				motor[leftLift] = motor[rightLift] = 0;
			} else if (SensorValue(MLP) > thresholdLft+100) {
				motor[leftLift] = motor[rightLift] = -liftMotorSpeed;
			} else if (SensorValue(MLP) < thresholdLft) {
				motor[leftLift] = motor[rightLift] = liftMotorSpeed+20;
			}
		}

		//ML Lif
		if (vexRT[Btn7U] == 1) {
			manualMGL = false;
			thresholdML = 500;
		} else if (vexRT[Btn7L] == 1) {
			manualMGL = false;
			thresholdML = 200;
		}

		if (vexRT[Btn5U] == 1) {
			manualMGL = true;
			motor[mobilLift] = 75;
		} else if (vexRT[Btn5D] == 1) {
			manualMGL = true;
			motor[mobilLift] = -75;
		} else if (manualMGL) {
			motor[mobilLift] = 0;
		}

		if (!manualMGL) {
			if (SensorValue(MGP) > thresholdML && SensorValue(MGP) < thresholdML+250) {
				motor[mobilLift] = 0;
			} else if (SensorValue(MGP) < thresholdML) {
				motor[mobilLift] = 50;
			} else if (SensorValue(MGP) > thresholdML+250) {
				motor[mobilLift] = -50;
			}
		}

		//Claw
		if (vexRT[Btn7D] == 1) { //press 7U button
				motor[claw] = -clawMotorSpeed; //move claw to close
		} else if (vexRT[Btn7R] == 1) { //press 7D button
				motor[claw] = clawMotorSpeed; //move claw to open
		} else {
				motor[claw] = 0;
		}

		//Drive
		motor[topRightD] = vexRT[Ch2];
		motor[botRightD] = vexRT[Ch2]*1.1; //this will be removed
		motor[topLeftD] = motor[botLeftD] = vexRT[Ch3];
		}
}
