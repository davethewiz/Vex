#pragma config(Sensor, in1,    leftML,         sensorPotentiometer)
#pragma config(Sensor, in2,    rightML,        sensorPotentiometer)
#pragma config(Sensor, in3,    liftH,          sensorPotentiometer)
#pragma config(Motor,  port2,           topLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           botLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           botRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mobilLift,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


void pre_auton()
{
  bStopTasksBetweenModes = true;
}

void translateBase(int speed, int time) {
	motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = speed;
	delay(time);
  motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = 0;
}

void rotateBase(int speed, int time) { //making the speed negative flips the direction of rotation
	motor[botRightD] = motor[topRightD] = speed;
	motor[botLeftD] = motor[topLeftD] = -speed;
	delay(time);
  motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = 0;
}

void moveLift(int speed, int time) {
	motor[rightLift] = motor[leftLift] = -speed;
	delay(time);
	motor[leftLift] = motor[rightLift] = 0;
}

void moveMobLift(int speed, int time) {
	motor[mobilLift] = speed;
	delay(time);
	motor[mobilLift] = 0;
}

void moveClaw(int speed, int time) {
	motor[claw] = speed;
	delay(time);
	motor[claw] = 0;
}

task autonomous() //AUTON
{
	rotateBase(-50, 200); //rotate slighty for adjustment to new base rot beginning movement thing
	moveLift(127, 150); //raise lift
	moveLift(-127, 150); //drop lift
	delay(500);
	moveLift(100, 2000); //raise lift
	moveMobLift(100, 400); //move mobil lift up a little bit
  translateBase(100, 2750); //move forward
  moveMobLift(100, 1250); //raise mobil lift
  delay(1000); //wait a sec
  translateBase(-100, 1750); //move backward
  rotateBase(100, 2900/2); //rotate 180
  translateBase(100, 3550); //move forward
  moveMobLift(-100, 1000); //move lift down
  translateBase(-100, 500); //move backward a little bit
  moveLift(-100, 1600);
  moveClaw(100, 1000);
  translateBase(-100, 525); //move backward a little bit*/

  /*new things below (for going for another mobile goal (everything above is 15 seconds)
  translateBase(-100, 1000);
  rotateBase(100, 2500/4);
  translateBase(100, 2500);
  rotateBase(100, 2500/4);*/
}

int clawMotorSpeed = 127;
int liftMotorSpeed = 50;
int thresholdML = 0;
int thresholdLft = 2700;
bool manualLift = false;

task usercontrol() //USER CONTROL
{
  while (true)
  {
  	//Normal Lift
		if (vexRT[Btn8U] == 1) {
			thresholdLft = 1100;
			manualLift = false;
		} else if (vexRT[Btn8D] == 1) {
			manualLift = false;
			thresholdLft = 2700;
		} else if (vexRT[Btn8L] == 1) {
			manualLift = false;
			thresholdLft = 2000;
		}

		if (vexRT[Btn6U] == 1) { //press 6U button
				manualLift = true;
				motor[rightLift] = motor[leftLift] = -liftMotorSpeed*2; //move lift to open
		} else if(vexRT[Btn6D] == 1) { //press 6D button
				manualLift = true;
				motor[rightLift] = motor[leftLift] = liftMotorSpeed*2; //move lift to close
		} else if (manualLift) { //if we don't have any buttons pressed
				motor[rightLift] = motor[leftLift] = 0; //don't move the lift
		}

		if (!manualLift) {
			if (SensorValue(liftH) > thresholdLft && SensorValue(liftH) < thresholdLft+100) {
				motor[leftLift] = motor[rightLift] = 0;
			} else if (SensorValue(liftH) > thresholdLft+100) {
				motor[leftLift] = motor[rightLift] = -liftMotorSpeed;
			} else if (SensorValue(liftH) < thresholdLft) {
				motor[leftLift] = motor[rightLift] = liftMotorSpeed+20;
			}
		}


		//ML Lift
		if (vexRT[Btn7U] == 1) {
			thresholdML = 2150;
		} else if (vexRT[Btn7D] == 1) {
			thresholdML = 400;
		}

		if (SensorValue(rightML) > thresholdML && SensorValue(rightML) < thresholdML+250) {
			motor[mobilLift] = 0;
		} else if (SensorValue(rightML) < thresholdML) {
			motor[mobilLift] = 40;
		} else if (SensorValue(rightML) > thresholdML+250) {
			motor[mobilLift] = -40;
		}

		//Claw
		if (vexRT[Btn5U] == 1) { //press 7U button
				motor[claw] = -clawMotorSpeed; //move claw to close
		} else if (vexRT[Btn5D] == 1) { //press 7D button
				motor[claw] = clawMotorSpeed; //move claw to open
		} else {
				motor[claw] = 0;
		}

		//Drive
		motor[topRightD] = motor[botRightD] = vexRT[Ch2];
		motor[topLeftD] = motor[botLeftD] = vexRT[Ch3];
		}
}
