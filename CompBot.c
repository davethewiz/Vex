#pragma config(Sensor, in1,    MLP,            sensorPotentiometer)
#pragma config(Sensor, in2,    MGP,            sensorPotentiometer)
#pragma config(Sensor, in3,    ,               sensorPotentiometer)
#pragma config(Motor,  port2,           topLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           botLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           botRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mobilLift,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


void pre_auton()
{
  bStopTasksBetweenModes = true;
}

void translateBase(byte speed, int time) {
	motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = speed;
	delay(time);
  motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = 0;
}

void rotateBase(byte speed, int time) { //making the speed negative flips the direction of rotation
	motor[botRightD] = motor[topRightD] = speed;
	motor[botLeftD] = motor[topLeftD] = -speed;
	delay(time);
  motor[botRightD] = motor[botLeftD] = motor[topRightD] = motor[topLeftD] = 0;
}

void moveLift(byte speed, int time) {
	motor[rightLift] = motor[leftLift] = -speed;
	delay(time);
	motor[leftLift] = motor[rightLift] = 0;
}

void moveMobLift(byte speed, int time) {
	motor[mobilLift] = speed;
	delay(time);
	motor[mobilLift] = 0;
}

void moveClaw(byte speed, int time) {
	motor[claw] = speed;
	delay(time);
	motor[claw] = 0;
}

void mobLiftUp(byte speed) {
	while (SensorValue(MGP) < 2500) {
		motor[mobilLift] = speed;
	}
	motor[mobilLift] = 0;
}

void mobLiftDown(byte speed) {
	while (SensorValue(MGP) > 800) {
		motor[mobilLift] = -speed;
	}
	motor[mobilLift] = 0;
}

bool blueSide = false;

task autonomousL() {
	moveLift(100, 2400);
	mobLiftDown(65);
}

task autonomous() 
{
	rotateBase(-50, 100); //tiny turn at beginning
	moveLift(100, 2500);
	mobLiftDown(65);
  translateBase(100, 3200); //move forward
  mobLiftUp(65);
  delay(200); //wait a sec
  translateBase(-100, 3000); //move backward
  rotateBase(100, 3500); //rotate a little bit to white line
  translateBase(100, 2750); //move forward
 //	rotateBase(100, 800);
 	//translateBase(100, 2500);
  moveMobLift(-50, 1300*1.25); //move lift down
  translateBase(-100, 1000); //move backward a little bit
  moveMobLift(127, 100); //move lift down
}

int clawMotorSpeed = 127;
int liftMotorSpeed = 100;
int thresholdML = 2500;
int thresholdLft = 2700;
bool manualLift = false;
bool manualMGL = false;

task usercontrol() //USER CONTROL
{
  while (true)
  {
  	//Normal Lift
		if (vexRT[Btn8U] == 1) {
			manualLift = false;
			thresholdLft = 1100;
		} else if (vexRT[Btn8D] == 1) {
			manualLift = false;
			thresholdLft = 2500;
		} else if (vexRT[Btn8L] == 1) {
			manualLift = false;
			thresholdLft = 2000;
		}

		if (vexRT[Btn6U] == 1) { //press 6U button
				manualLift = true;
				motor[rightLift] = motor[leftLift] = -liftMotorSpeed; //move lift to open
		} else if(vexRT[Btn6D] == 1) { //press 6D button
				manualLift = true;
				motor[rightLift] = motor[leftLift] = liftMotorSpeed; //move lift to close
		} else if (manualLift) { //if we don't have any buttons pressed
				motor[rightLift] = motor[leftLift] = 0; //don't move the lift
		}

		if (!manualLift) {
			if (SensorValue(MLP) > thresholdLft && SensorValue(MLP) < thresholdLft+100) {
				motor[leftLift] = motor[rightLift] = 0;
			} else if (SensorValue(MLP) > thresholdLft+100) {
				motor[leftLift] = motor[rightLift] = -liftMotorSpeed;
			} else if (SensorValue(MLP) < thresholdLft) {
				motor[leftLift] = motor[rightLift] = liftMotorSpeed+20;
 			}
		}

		//ML Lif
		if (vexRT[Btn7U] == 1) {
			manualMGL = false;
			thresholdML = 1000;
		} else if (vexRT[Btn7L] == 1) {
			manualMGL = false;
			thresholdML = 325;
		}

		if (vexRT[Btn5U] == 1) {
			manualMGL = true;
			motor[mobilLift] = 50;
		} else if (vexRT[Btn5D] == 1) {
			manualMGL = true;
			motor[mobilLift] = -50;
		} else if (manualMGL) {
			motor[mobilLift] = 0;
		}

		if (!manualMGL) {
			if (SensorValue(MGP) > thresholdML && SensorValue(MGP) < thresholdML+250) {
				motor[mobilLift] = 0;
			} else if (SensorValue(MGP) < thresholdML) {
				motor[mobilLift] = 50;
			} else if (SensorValue(MGP) > thresholdML+250) {
				motor[mobilLift] = -50;
			}
		}

		//Claw
		if (vexRT[Btn7D] == 1) { //press 7U button
				motor[claw] = -clawMotorSpeed; //move claw to close
		} else if (vexRT[Btn7R] == 1) { //press 7D button
				motor[claw] = clawMotorSpeed; //move claw to open
		} else {
				motor[claw] = 0;
		}

		//Drive
		motor[topRightD] = vexRT[Ch2];
		motor[botRightD] = vexRT[Ch2]*1.1; //this will be removed
		motor[topLeftD] = motor[botLeftD] = vexRT[Ch3];
		}
}
