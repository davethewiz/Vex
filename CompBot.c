#pragma config(Sensor, in1,    leftML,         sensorPotentiometer)
#pragma config(Sensor, in2,    rightML,        sensorPotentiometer)
#pragma config(Sensor, in3,    liftH,          sensorPotentiometer)
#pragma config(Motor,  port2,           topLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           botLeftD,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           botRightD,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mobilLift,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


void pre_auton()
{
  bStopTasksBetweenModes = true;
}

void translateBase(int speed, int time) {
	motor[botRightD] = motor[botLeftD] = speed;
	delay(time);
	motor[botRightD] = motor[botLeftD] = 0;
}

void rotateBase(int speed, int time) { //making the speed negative flips the direction of rotation
	motor[botRightD] = speed;
	motor[botLeftD] = -speed;
	delay(time);
  motor[botRightD] = motor[botLeftD] = 0;
}

void moveLift(int speed, int time) {
	motor[rightLift] = motor[leftLift] = -speed;
	delay(time);
	motor[leftLift] = motor[rightLift] = 0;
}

void moveMobLift(int speed, int time) {
	motor[mobilLift] = speed;
	delay(time);
	motor[mobilLift] = 0;
}

task autonomous() //AUTON
{
	moveLift(100, 2000); //raise lift
	moveMobLift(100, 400); //move mobil lift up a little bit
  translateBase(100, 3000); //move forward
  moveMobLift(100, 1250); //raise mobil lift
  delay(1000); //wait a sec
  translateBase(-100, 1250); //move backward
  rotateBase(100, 2800/2); //rotate 180
  translateBase(100, 3550); //move forward
  moveMobLift(-100, 1000); //move lift down
  translateBase(-100, 500); //move backward a little bit


  /*new things below (for going for another mobile goal (everything above is 15 seconds)
  translateBase(-100, 1000);
  rotateBase(100, 2500/4);
  translateBase(100, 2500);
  rotateBase(100, 2500/4);*/
}

int clawMotorSpeed = 100;
int liftMotorSpeed = 100;
int thresholdML = 400;
int thresholdLft = 2000;

task usercontrol() //USER CONTROL
{
  while (true)
  {
		if (vexRT[Btn7U] == 1) {
			thresholdML = 400;
		} else if (vexRT[Btn7D] == 1) {
			thresholdML = 2150;
		}

		if (vexRT[Btn6U] == 1) {
			thresholdLft = 1100;
		} else if (vexRT[Btn6D] == 1) {
			thresholdLft = 2700;
		} else if (vexRT[Btn8U] == 1) {
			thresholdLft = 2000;
		}

if (SensorValue(liftH) > thresholdLft && SensorValue(liftH) < thresholdLft+100) {
			motor[leftLift] = motor[rightLift] = 0;
		} else if (SensorValue(liftH) > thresholdLft+100) {
			motor[leftLift] = motor[rightLift] = -55;
		} else if (SensorValue(liftH) < thresholdLft) {
			motor[leftLift] = motor[rightLift] = 70;
		}

		if (SensorValue(rightML) > thresholdML && SensorValue(rightML) < thresholdML+250) {
			motor[mobilLift] = 0;
		} else if (SensorValue(rightML) < thresholdML) {
			motor[mobilLift] = 40;
		} else if (SensorValue(rightML) > thresholdML+250) {
			motor[mobilLift] = -40;
		}

		if (vexRT[Btn5U] == 1) { //press 7U button
				motor[claw] = -clawMotorSpeed; //move claw to close
		} else if (vexRT[Btn5D] == 1) { //press 7D button
				motor[claw] = clawMotorSpeed; //move claw to open
		} else {
				motor[claw] = 0;
		}

	/*	if (vexRT[Btn6U] == 1) { //press 6U button
				motor[rightLift] = motor[leftLift] = -liftMotorSpeed; //move lift to open
		} else if(vexRT[Btn6D] == 1) { //press 6D button
				motor[rightLift] = motor[leftLift] = liftMotorSpeed; //move lift to close
		} else { //if we don't have any buttons pressed
				motor[rightLift] = motor[leftLift] = 0; //don't move the lift
		}*/

		motor[topRightD] = motor[botRightD] = vexRT[Ch2];
		motor[topLeftD] = motor[botLeftD] = vexRT[Ch3];
		}
}
